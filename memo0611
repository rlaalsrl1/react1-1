[2]Specialization(특수화, 전문화)
-웰컴다이얼로그는 다이얼로그의 특별한 케이스입니다.
-범용적인 개념을 구별이 되게 구체화하는 것을 특수화라고 합니다.
-객체지향 언어에서는 상속을 사용하여 특수화를 구현.
-리액트에서는 합성을 사용하여 특수화를 구현.


-합셩과 대비되는 개념으로 상속(inheritance)이 있습니다.
-자식 클래스는 부모 클래스가 가진 변수나 함수 등의 속성을 모두 갖게 되는 개념
-하지만 리액트에서는 상속보다는 합성을 자주 사용

14.1 컨텍스트란 무엇인가?
-기존의 일반적인 리액트에서는 데이터가 컴포넌트의 props를 통해 부모에서 자식으로
단방향으로 전달되었음
-컨텍스트는 리액트 컴포넌트들 사이에서 데이터를 기존의 props를통해 전달하는 방식 대신
'컴포넌트 트리를 통해 곧바로 컴포넌트에 전달하는 새로운 방식'을 제공함
-이 것을 통해 어떤 컴포넌트라도 쉽게 데이터에 접근할 수 있음
-컨텍스트를 사용하면 일일이 props로 전달할 필요 없이 데이터를 필요로 하는 컴포넌트에
곧바로 데이터를 전달할 수 있음

14.2 언제 컨텍스트를 사용해야 할까?
-여러 컴포넌트에서 자주 필요로 하는 데이터는 로그인 여부, 로그인 정보, UI테마,
현재 선택된 언어 등이 있음
-이런 데이터들을 기존의 방식대로 컴포넌트의 props를 통해 넘겨주는 예를 
페이지 382에서 보여주고 있음(참고)
-props를 통해 데이터를 전달하는 기존방식은 실제 데이터를 필요로하는 
컴포넌트까지의 깊이가 깊어질 수록 복잡해 짐
-또한 반복적인 코드를 계속해서 작성해 주어야 하기 때문에 비효율적이고 가독성이 떨어짐
-컨텍스트를 사용하면 이러한 방식을 깔끔하게 개선할 수 있음

14.3 컨텍스트를 사용하기 전에 고려할 점
-컨텍스트는 다른 레벨의 많은 컴포넌트가 특정 데이터를 필요로 하는 경우에 주로 사용함
-하지만 무조건 컨텍스트를 사용하는 것이 좋은것은 아님
-컴포넌트와 컨텍스트가 연동되면 재사용성이 떨어지기 떄문
-따라서 다른 레벨의 많은 컴포넌트가 데이터를 필요로 하는 경우가 아니면 props를 
통해 데이터를 전달하는 컴포넌트 합성 방법이 더 적합함

-페이지 395의 예제처럼 실제 user와 avatarSize를 사용하는 것은 Avatar컴포넌트 뿐인데
여러 단계에 걸쳐 props를 전달하고 있음
-이런 경우 컨텍스트를 사용하지 않고 문제를 해결할 수 있는 방법은 Avatar컴포넌트를 
변수에 저장하여 직접 넘겨주는 것(9장 참고)
-이렇게 하면 중간 단계의 컴포넌트들은 user와 avatarSize에 대해 몰라도 됨
(페이지 396의 예제 참고)
-허나 예제처럼 하는것이 모든 상황에서 좋은것은 아님
-데이터가 많아질수록 상위 컴포넌트가 점점 더 복잡해지기 때문
-이런 경우 하위 컴포넌트를 여러개의 변수로 나눠서 전달하면 됨
(페이지 397의 예제 참고)

-허나 어떤 경우에는 하나의 데이터에 다양한 레벨에 있는 중첩된 컴포넌트들의 접근이
필요할 수 있음
-이런 경우라면 컨텍스트가 유리
-컨텍스트는 해당 테이터의 변경사항을 모두 하위 컴포넌트들에세 broadcast해주기 
때문임
-컨텍스트를 사용하기에 적합한 데이터의 대표적인 예로는 '지역 정보', 'UI테마' 그리고 
'캐싱된 데이터' 등이 있음

14.4 컨텍스트 API
[1]React.createContext
-컨텍스트를 생성하기 위한 함수
-파라미터에는 기본값을 넣어주면 됨
-하위 컴포넌트는 가장 가까운 상위 레벨의 Provider로 부터 컨텍스트를 받게 되지만
,만일 Provider를 찾을 수 없다면 초기값을 사용하게 됨
ex) const MyContext = React.createContext(기본값);

[2]Context.Provider
-Context.Provider 컴포넌트로 하위 컴포넌트들을 감싸주면 모든 하위 컴포넌트들이
해당 컨텍스트의 데이터에 접근할 수 있게 됨
ex) <MyContext.Provider value={/*some value */}>
-Provider컴포넌트에는 value라는 prop이 있고, 이것은 Provider컴포넌트 하위에 있는
컴포넌트에게 전달됨
-하위 컴포넌트를 consumer 컴포넌트라고 부름
(페이지 399 Note.Provider value에서 주의해야 할 사항. 참고)

[3]Class.ContextType
-Provider 하위에 있는 클래스 컴포넌트에서 컨텍스트의 데이터에 접근하기 위해 사용
-Class컴포넌트는 더 이상 사용하지 않음으로 참고만

[4]Context.Consumer
-함수형 컴포넌트에서 Context.Consumer를 사용하여 컨텍스트를 구독할 수 있음
ex) <MyContext.Consumer>
        {value => /*컨텍스트의 값에 따라서 컴포넌트들을 렌더링 */}
    </MyContext.Consumer>
-컴포넌트의 자식으로 함수가 올 수 있는데 이것을 function as a child라고 부름
-Context.Consumer로 감싸주면 자식으로 들어간 함수가 현재 컨텍스트의 value를 받아서
리액트 노드로 리턴하게 됨
- 이때 함수로 전달되는 value는 Provider의 value prop와 동일
-만약 상위 컴포넌트에 Provider가 없다면 이 value 파라미터는 createContext()
를 호출할 때 넣는 기본값과 동일한 역할을 함

[5]Context.displayName
-컨텍스트 객체는 displayName이라는 문자열 속성을 가짐
-크롬의 리액트 개발자 도구에서는 컨텍스트의 Provider나 Consumer를 표시할 때
displayName을 함께 표시해 줌

14.5 여러개의 컨텍스트 사용하기에
-여러개의 컨텍스트를 동시에 사용하려면 Context.Provider를 중첩해서 사용함
(예제 코드는 페이지 403~ 404에 있음)
-예제에서는 ThemeContext와 UserContext를 중첩해서 사용하고 있음
-이런 방법으로 여러개의 컨텍스트를 동시에 사용할 수 있음
-하지만 두 개 또는 그 이상의 컨텍스트 값이 자주 함께 사용될 경우 모든 값을
한번에 저공해 주는 별도의 render prop컴포넌트를 직접 만드는 것을 고려하는 게 좋음

14.6 useContext
-함수형 컴포넌트에서 컨텍스트를 사용하기 위해 컴포넌트를 매번 Consumer컴포넌트로 
감싸주는 것보다 더 좋은 방법이 있음. 바로 7장에서 배운 Hook
-useContext() 혹은 React.createContext()함수 호출로 생성된 컨텍스트 객체를 인자로 받아서
현재 컨텍스트 값을 리턴함

-이 방법도 가장 가까운 상위 Provider로 부터 컨텍스트의 값을 받아옴
-만일 값이 변경되면 useContext() 훅을 사용하는 컴포넌트가 재렌더링됨
-그렇기에 useContext()훅을 사용하는 컴포넌트의 렌더링이 꽤 무거운 작업일 경우에는
별도로 최적화 작업을 해주 필요가 있음
